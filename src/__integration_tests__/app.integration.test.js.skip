import React from 'react'
import { render, screen, waitFor } from '@testing-library/react'
import { Provider } from 'react-redux'
import { MemoryRouter } from 'react-router-dom'
import configureMockStore from 'redux-mock-store'
import { thunk } from 'redux-thunk'
import * as authActions from '../actions/authActions'
import * as ticketActions from '../actions/ticketActions'

// Mock the lazy loaded components
jest.mock('../layout/DefaultLayout', () => {
  return function DefaultLayout() {
    return <div>Default Layout</div>
  }
})

jest.mock('../layout/PublicLayout', () => {
  const { Outlet } = require('react-router-dom')
  return function PublicLayout() {
    return (
      <div>
        Public Layout
        <Outlet />
      </div>
    )
  }
})

jest.mock('../views/pages/login/Login', () => {
  return function Login() {
    return <div>Login Component</div>
  }
})

jest.mock('../views/pages/register/Register', () => {
  return function Register() {
    return <div>Register Component</div>
  }
})

// Mock actions
jest.mock('../actions/authActions')
jest.mock('../actions/ticketActions')

const middlewares = [thunk]
const mockStore = configureMockStore(middlewares)

describe('App Integration Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('Authentication Flow', () => {
    it('should check authentication on mount', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: false })
      const mockGetTickets = jest.fn().mockResolvedValue({ error: false })

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: false,
          user: null,
        },
      })

      // Note: In real application, App component calls these on mount
      // We're testing the action flow here
      await store.dispatch(mockCheckAuth())

      expect(mockCheckAuth).toHaveBeenCalled()
    })

    it('should fetch tickets after successful authentication', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: false })
      const mockGetTickets = jest.fn().mockResolvedValue({ error: false })

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: true,
            },
          },
        },
      })

      await store.dispatch(mockCheckAuth())
      await store.dispatch(mockGetTickets())

      expect(mockCheckAuth).toHaveBeenCalled()
      expect(mockGetTickets).toHaveBeenCalled()
    })

    it('should handle authentication check failure', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: true })
      const mockGetTickets = jest.fn()

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: false,
          user: null,
        },
      })

      const result = await store.dispatch(mockCheckAuth())

      expect(mockCheckAuth).toHaveBeenCalled()
      expect(result.error).toBe(true)
      expect(mockGetTickets).not.toHaveBeenCalled()
    })

    it('should handle ticket fetch failure gracefully', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: false })
      const mockGetTickets = jest.fn().mockResolvedValue({ error: true })

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: true,
            },
          },
        },
      })

      await store.dispatch(mockCheckAuth())
      const result = await store.dispatch(mockGetTickets())

      expect(mockGetTickets).toHaveBeenCalled()
      expect(result.error).toBe(true)
    })
  })

  describe('Route Guards Integration', () => {
    it('should show login page for unauthenticated users', () => {
      const store = mockStore({
        auth: {
          isAuthenticated: false,
          user: null,
        },
      })

      const Login = require('../views/pages/login/Login').default
      render(
        <Provider store={store}>
          <MemoryRouter>
            <Login />
          </MemoryRouter>
        </Provider>,
      )

      expect(screen.getByText('Login Component')).toBeInTheDocument()
    })

    it('should verify authentication state for active users', () => {
      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: true,
            },
          },
        },
      })

      const state = store.getState()
      expect(state.auth.isAuthenticated).toBe(true)
      expect(state.auth.user.user.active).toBe(true)
    })

    it('should verify authentication state for inactive users', () => {
      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: false,
            },
          },
        },
      })

      const state = store.getState()
      expect(state.auth.isAuthenticated).toBe(true)
      expect(state.auth.user.user.active).toBe(false)
    })
  })

  describe('Error Handling', () => {
    it('should handle authentication check exception', async () => {
      const mockCheckAuth = jest.fn().mockRejectedValue(new Error('Network error'))
      authActions.checkAuthentication = mockCheckAuth

      const store = mockStore({
        auth: {
          isAuthenticated: false,
          user: null,
        },
      })

      await expect(store.dispatch(mockCheckAuth())).rejects.toThrow('Network error')
      expect(mockCheckAuth).toHaveBeenCalled()
    })

    it('should handle ticket fetch exception', async () => {
      const mockGetTickets = jest.fn().mockRejectedValue(new Error('API error'))
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: true,
            },
          },
        },
      })

      await expect(store.dispatch(mockGetTickets())).rejects.toThrow('API error')
      expect(mockGetTickets).toHaveBeenCalled()
    })
  })

  describe('State Management Integration', () => {
    it('should properly integrate with Redux store', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: false })
      const mockGetTickets = jest.fn().mockResolvedValue({ error: false })

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: true,
            },
          },
        },
      })

      await store.dispatch(mockCheckAuth())

      const actions = store.getActions()
      expect(actions.length).toBeGreaterThan(0)
    })

    it('should dispatch actions in correct order', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: false })
      const mockGetTickets = jest.fn().mockResolvedValue({ error: false })

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: true,
            },
          },
        },
      })

      await store.dispatch(mockCheckAuth())
      await store.dispatch(mockGetTickets())

      // checkAuthentication should be called before getAllTicketAPI
      const checkAuthCallOrder = mockCheckAuth.mock.invocationCallOrder[0]
      const getTicketsCallOrder = mockGetTickets.mock.invocationCallOrder[0]
      expect(checkAuthCallOrder).toBeLessThan(getTicketsCallOrder)
    })
  })

  describe('Complex Workflow Integration', () => {
    it('should handle complete user session flow', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: false })
      const mockGetTickets = jest.fn().mockResolvedValue({ error: false })
      const mockLogout = jest.fn().mockResolvedValue({ error: false })

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets
      authActions.logout = mockLogout

      const store = mockStore({
        auth: {
          isAuthenticated: true,
          user: {
            user: {
              uid: '123',
              active: true,
            },
          },
        },
      })

      // Check auth
      await store.dispatch(mockCheckAuth())
      // Fetch tickets
      await store.dispatch(mockGetTickets())
      // Logout
      await store.dispatch(mockLogout())

      expect(mockCheckAuth).toHaveBeenCalled()
      expect(mockGetTickets).toHaveBeenCalled()
      expect(mockLogout).toHaveBeenCalled()
    })

    it('should handle partial workflow on errors', async () => {
      const mockCheckAuth = jest.fn().mockResolvedValue({ error: true })
      const mockGetTickets = jest.fn()

      authActions.checkAuthentication = mockCheckAuth
      ticketActions.getAllTicketAPI = mockGetTickets

      const store = mockStore({
        auth: {
          isAuthenticated: false,
          user: null,
        },
      })

      const result = await store.dispatch(mockCheckAuth())

      expect(result.error).toBe(true)
      // Tickets should not be fetched if auth fails
      expect(mockGetTickets).not.toHaveBeenCalled()
    })
  })
})
